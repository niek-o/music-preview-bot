import { MentionChannel, channelFactory } from "./channel.js";
import { GuildMember } from "./guild-member.js";
import { Channel } from "./channel.js";
import { User } from "./user.js";
import { Poll } from "./poll.js";
export class Message {
    id;
    author;
    channelId;
    content;
    timestamp;
    editedTimestamp = undefined;
    tts;
    mentionsEveryone;
    mentions;
    mentionedRoles;
    mentionedChannels;
    attachments;
    embeds;
    reactions;
    nonce;
    pinned;
    webhookId;
    type;
    activity;
    application;
    applicationId;
    messageReference;
    flags;
    referencedMessage;
    interactionMetadata;
    interaction;
    thread;
    components;
    stickerItems;
    stickers;
    position;
    roleSubscriptionData;
    resolved;
    poll;
    guildId;
    member;
    client;
    constructor(client, message) {
        this.client = client;
        this.id = message.id;
        this.channelId = message.channel_id;
        this.content = message.content;
        this.tts = message.tts;
        this.mentionsEveryone = message.mention_everyone;
        this.mentionedRoles = message.mention_roles;
        this.mentionedChannels = message.mention_channels?.map((channel) => new MentionChannel(client, channel)) ?? [];
        this.attachments = message.attachments;
        this.embeds = message.embeds;
        this.reactions = message.reactions;
        this.nonce = message.nonce;
        this.pinned = message.pinned;
        this.webhookId = message.webhook_id;
        this.type = message.type;
        this.activity = message.activity;
        this.application = message.application;
        this.applicationId = message.application_id;
        this.messageReference = message.message_reference;
        this.flags = message.flags ?? 0;
        this.interactionMetadata = message.interaction_metadata;
        this.interaction = message.interaction;
        this.components = message.components;
        this.stickerItems = message.sticker_items;
        this.stickers = message.stickers;
        this.position = message.position;
        this.roleSubscriptionData = message.role_subscription_data;
        this.resolved = message.resolved;
        this.guildId = message.guild_id;
        if (typeof message.author !== "undefined")
            this.author = new User(client, message.author);
        if (typeof message.timestamp !== "undefined")
            this.timestamp = new Date(message.timestamp);
        if (typeof message.mentions !== "undefined")
            this.mentions = message.mentions.map((mention) => new User(client, mention));
        if (typeof message.thread !== "undefined")
            this.thread = channelFactory(client, message.thread);
        if ("member" in message)
            this.member = new GuildMember(client, message.member);
        if (typeof message.poll !== "undefined")
            this.poll = new Poll(client, message.channel_id, message.id, message.poll);
        if (message.referenced_message != null)
            this.referencedMessage = new Message(client, message.referenced_message);
        if (message.edited_timestamp != null)
            this.editedTimestamp = new Date(message.edited_timestamp);
    }
    async reply(content, options) {
        let flags = 0;
        let data;
        let files;
        if (typeof content === "string") {
            if (typeof options !== "undefined") {
                const { suppressEmbeds, suppressNotifications, flags: fl, files: f, ...obj } = options;
                if (suppressEmbeds)
                    flags |= 4;
                if (suppressNotifications)
                    flags |= 4096;
                flags |= fl ?? 0;
                files = f;
                data = {
                    ...obj,
                    content
                };
            }
            else
                data = { content };
        }
        else {
            const { suppressEmbeds, suppressNotifications, flags: fl, files: f, ...obj } = content;
            flags |= fl ?? 0;
            if (suppressEmbeds)
                flags |= 4;
            if (suppressNotifications)
                flags |= 4096;
            files = f;
            data = obj;
        }
        return new Message(this.client, await this.client.rest.createMessage(this.channelId, {
            ...data,
            flags,
            message_reference: {
                message_id: this.id
            }
        }, files));
    }
    async sendInChannel(content, options) {
        let flags = 0;
        let data;
        let files;
        if (typeof content === "string") {
            if (typeof options !== "undefined") {
                const { suppressEmbeds, suppressNotifications, flags: fl, files: f, ...obj } = options;
                flags |= fl ?? 0;
                if (suppressEmbeds)
                    flags |= 4;
                if (suppressNotifications)
                    flags |= 4096;
                files = f;
                data = {
                    ...obj,
                    content
                };
            }
            else
                data = { content };
        }
        else {
            const { suppressEmbeds, suppressNotifications, flags: fl, files: f, ...obj } = content;
            flags |= fl ?? 0;
            if (suppressEmbeds)
                flags |= 4;
            if (suppressNotifications)
                flags |= 4096;
            files = f;
            data = obj;
        }
        return new Message(this.client, await this.client.rest.createMessage(this.channelId, {
            ...data,
            flags
        }, files));
    }
    async forwardTo(channelId, content, options) {
        let flags = 0;
        let data;
        let files;
        if (typeof content === "string") {
            if (typeof options !== "undefined") {
                const { suppressEmbeds, suppressNotifications, flags: fl, files: f, ...obj } = options;
                flags |= fl ?? 0;
                if (suppressEmbeds)
                    flags |= 4;
                if (suppressNotifications)
                    flags |= 4096;
                files = f;
                data = {
                    ...obj,
                    content
                };
            }
            else
                data = { content };
        }
        else {
            const { suppressEmbeds, suppressNotifications, flags: fl, files: f, ...obj } = content;
            flags |= fl ?? 0;
            if (suppressEmbeds)
                flags |= 4;
            if (suppressNotifications)
                flags |= 4096;
            files = f;
            data = obj;
        }
        return new Message(this.client, await this.client.rest.createMessage(this.channelId, {
            ...data,
            flags,
            message_reference: {
                type: 1,
                channel_id: channelId
            }
        }, files));
    }
    async edit(content, options) {
        let flags = 0;
        let data;
        let files;
        if (typeof content === "string") {
            if (typeof options !== "undefined") {
                const { suppressEmbeds, flags: fl, files: f, ...obj } = options;
                flags |= fl ?? 0;
                if (suppressEmbeds)
                    flags = 4;
                files = f;
                data = {
                    ...obj,
                    content,
                    flags
                };
            }
            else
                data = { content, flags };
        }
        else {
            const { suppressEmbeds, flags: fl, files: f, ...obj } = content;
            flags |= fl ?? 0;
            if (suppressEmbeds)
                flags = 4;
            files = f;
            data = {
                ...obj,
                flags
            };
        }
        return new Message(this.client, await this.client.rest.editMessage(this.channelId, this.id, data, files));
    }
    async react(emoji, isCustomEmoji = false) {
        await this.client.rest.createReaction(this.channelId, this.id, emoji, isCustomEmoji);
    }
    async delete(reason) {
        await this.client.rest.deleteMessage(this.channelId, this.id, reason);
    }
    async crosspost() {
        await this.client.rest.crosspostMessage(this.channelId, this.id);
    }
    async pin() {
        await this.client.rest.pinMessage(this.channelId, this.id);
    }
    async unpin() {
        await this.client.rest.unpinMessage(this.channelId, this.id);
    }
    async startThread(options) {
        if (typeof options === "string")
            options = { name: options };
        return channelFactory(this.client, await this.client.rest.startThreadFromMessage(this.channelId, this.id, options));
    }
    async fetchChannel(force = false) {
        if (!force) {
            const cachedChannel = await this.client.cache.channels.get(this.channelId);
            if (typeof cachedChannel !== "undefined") {
                if (cachedChannel instanceof Channel)
                    return cachedChannel;
                return new Channel(this.client, cachedChannel, false);
            }
        }
        const channel = channelFactory(this.client, await this.client.rest.getChannel(this.channelId));
        await this.client.cache.channels.set(channel.id, channel);
        return channel;
    }
    hasContent() {
        return typeof this.content !== "undefined";
    }
    hasAttachments() {
        return typeof this.attachments !== "undefined" && this.attachments.length > 0;
    }
    hasEmbeds() {
        return typeof this.embeds !== "undefined" && this.embeds.length > 0;
    }
    hasComponents() {
        return typeof this.components !== "undefined" && this.components.length > 0;
    }
    hasStickers() {
        return typeof this.stickers !== "undefined" && this.stickers.length > 0;
    }
}
