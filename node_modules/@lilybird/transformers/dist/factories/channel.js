import { GuildMember } from "./guild-member.js";
import { Message } from "./message.js";
import { User } from "./user.js";
export function channelFactory(client, channel, resolved = false) {
    if (typeof channel.type === "undefined")
        throw new Error("Cannot parse invalid channel. Missing channel type");
    switch (channel.type) {
        case 0: {
            return new GuildTextChannel(client, channel, resolved);
        }
        case 1: {
            return new DMChannel(client, channel, resolved);
        }
        case 2: {
            return new GuildVoiceChannel(client, channel, resolved);
        }
        case 3: {
            return new GroupDMChannel(client, channel, resolved);
        }
        case 5: {
            return new GuildAnnouncementChannel(client, channel, resolved);
        }
        case 4: {
            return new GuildChannelCategory(client, channel, resolved);
        }
        case 10:
        case 11:
        case 12: {
            return new ThreadChannel(client, channel, resolved);
        }
        case 13:
        case 14: {
            return new GuildChannel(client, channel, resolved);
        }
        case 15:
        case 16: {
            return new ThreadLikeChannel(client, channel, resolved);
        }
    }
}
export class Channel {
    id;
    type;
    lastPinTimestamp;
    flags;
    client;
    constructor(client, channel, resolved) {
        this.client = client;
        this.id = channel.id;
        this.type = channel.type;
        this.lastPinTimestamp = channel.last_pin_timestamp;
        this.flags = channel.flags ?? 0;
        if (resolved)
            if (typeof channel.permissions !== "undefined")
                this.permissions = channel.permissions;
    }
    async send(content, options) {
        let flags = 0;
        let data;
        let files;
        if (typeof content === "string") {
            if (typeof options !== "undefined") {
                const { suppressEmbeds, suppressNotifications, flags: fl, files: f, ...obj } = options;
                flags |= fl ?? 0;
                if (suppressEmbeds)
                    flags |= 4;
                if (suppressNotifications)
                    flags |= 4096;
                files = f;
                data = {
                    ...obj,
                    content
                };
            }
            else
                data = { content };
        }
        else {
            const { suppressEmbeds, suppressNotifications, flags: fl, files: f, ...obj } = content;
            flags |= fl ?? 0;
            if (suppressEmbeds)
                flags |= 4;
            if (suppressNotifications)
                flags |= 4096;
            files = f;
            data = obj;
        }
        return new Message(this.client, await this.client.rest.createMessage(this.id, {
            ...data,
            flags
        }, files));
    }
    isText() {
        return this.type === 0;
    }
    isDM() {
        return this.type === 1;
    }
    isVoice() {
        return this.type === 2;
    }
    isGroupDM() {
        return this.type === 3;
    }
    isCategory() {
        return this.type === 4;
    }
    isAnnouncement() {
        return this.type === 5;
    }
    isAnnouncementThread() {
        return this.type === 10;
    }
    isPublicThread() {
        return this.type === 11;
    }
    isPrivateThread() {
        return this.type === 12;
    }
    isStageVoice() {
        return this.type === 13;
    }
    isDirectory() {
        return this.type === 14;
    }
    isForum() {
        return this.type === 15;
    }
    isMedia() {
        return this.type === 16;
    }
}
export class MentionChannel extends Channel {
    guildId;
    name;
    constructor(client, channel) {
        super(client, channel, false);
        this.guildId = channel.guild_id;
        this.name = channel.name;
    }
}
export class GuildChannel extends Channel {
    guildId;
    name;
    position;
    permissionOverwrites;
    nsfw;
    topic;
    lastMessageId;
    parentId;
    defaultAutoArchiveDuration;
    constructor(client, channel, resolved) {
        super(client, channel, resolved);
        this.guildId = channel.guild_id;
        this.name = channel.name;
        this.position = channel.position;
        this.permissionOverwrites = channel.permission_overwrites;
        this.nsfw = channel.nsfw;
        this.topic = channel.topic;
        this.lastMessageId = channel.last_message_id;
        this.parentId = channel.parent_id;
        this.defaultAutoArchiveDuration = channel.default_auto_archive_duration;
    }
}
export class GuildTextChannel extends GuildChannel {
    rateLimitPerUser;
    constructor(client, channel, resolved) {
        super(client, channel, resolved);
        this.rateLimitPerUser = channel.rate_limit_per_user;
    }
}
export class GuildAnnouncementChannel extends GuildChannel {
}
export class GuildVoiceChannel extends Channel {
    guildId;
    name;
    position;
    permissionOverwrites;
    lastMessageId;
    parentId;
    nsfw;
    rateLimitPerUser;
    rtcRegion;
    userLimit;
    bitrate;
    videoQualityMode;
    constructor(client, channel, resolved) {
        super(client, channel, resolved);
        this.guildId = channel.guild_id;
        this.name = channel.name;
        this.position = channel.position;
        this.permissionOverwrites = channel.permission_overwrites;
        this.lastMessageId = channel.last_message_id;
        this.parentId = channel.parent_id;
        this.nsfw = channel.nsfw;
        this.rateLimitPerUser = channel.rate_limit_per_user;
        this.rtcRegion = channel.rtc_region;
        this.userLimit = channel.user_limit;
        this.bitrate = channel.bitrate;
        this.videoQualityMode = channel.video_quality_mode ?? 1;
    }
}
export class DMChannel extends Channel {
    lastMessageId;
    recipients;
    constructor(client, channel, resolved) {
        super(client, channel, resolved);
        this.lastMessageId = channel.last_message_id;
        this.recipients = channel.recipients.map((user) => new User(client, user));
    }
}
export class GroupDMChannel extends DMChannel {
    name;
    icon;
    ownerId;
    applicationId;
    managed;
    constructor(client, channel, resolved) {
        super(client, channel, resolved);
        this.name = channel.name;
        this.icon = channel.icon;
        this.ownerId = channel.owner_id;
        this.applicationId = channel.application_id;
        this.managed = channel.managed;
    }
    isManaged() {
        return !!this.managed;
    }
}
export class GuildChannelCategory extends Channel {
    permissionOverwrites;
    name;
    nsfw;
    position;
    guildId;
    rateLimitPerUser;
    constructor(client, channel, resolved) {
        super(client, channel, resolved);
        this.permissionOverwrites = channel.permission_overwrites;
        this.name = channel.name;
        this.nsfw = channel.nsfw;
        this.position = channel.position;
        this.guildId = channel.guild_id;
        this.rateLimitPerUser = channel.rate_limit_per_user;
    }
}
export class ThreadChannel extends Channel {
    guildId;
    parentId;
    ownerId;
    name;
    lastMessageId;
    messageCount;
    memberCount;
    threadMetadata;
    totalMessageSent;
    member;
    defaultThreadRateLimitPerUser;
    constructor(client, channel, resolved) {
        super(client, channel, resolved);
        this.guildId = channel.guild_id;
        this.parentId = channel.parent_id;
        this.ownerId = channel.owner_id;
        this.name = channel.name;
        this.lastMessageId = channel.last_message_id;
        this.messageCount = channel.message_count;
        this.memberCount = channel.member_count;
        this.threadMetadata = channel.thread_metadata;
        this.totalMessageSent = channel.total_message_sent;
        this.defaultThreadRateLimitPerUser = channel.default_thread_rate_limit_per_user ?? 0;
        if (typeof channel.member !== "undefined")
            this.member = new ThreadMember(client, channel.member);
        if ("newly_created" in channel)
            this.newlyCreated = channel.newly_created;
    }
    hasMember() {
        return typeof this.member !== "undefined";
    }
}
export class ThreadMember {
    id;
    userId;
    joinTimestamp;
    flags;
    member;
    constructor(client, member) {
        this.id = member.id;
        this.userId = member.user_id;
        this.joinTimestamp = new Date(member.join_timestamp);
        this.flags = member.flags;
        if (typeof member.member !== "undefined")
            this.member = new GuildMember(client, member.member);
    }
}
export class ThreadLikeChannel extends Channel {
    availableTags;
    appliedTags;
    defaultThreadRateLimitPerUser;
    defaultSortOrder;
    defaultForumLayout;
    defaultReactionEmoji;
    constructor(client, channel, resolved) {
        super(client, channel, resolved);
        this.availableTags = channel.available_tags;
        this.appliedTags = channel.applied_tags;
        this.defaultThreadRateLimitPerUser = channel.default_thread_rate_limit_per_user;
        this.defaultSortOrder = channel.default_sort_order;
        this.defaultForumLayout = channel.default_forum_layout;
        this.defaultReactionEmoji = channel.default_reaction_emoji;
    }
}
