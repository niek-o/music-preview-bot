import { ApplicationCommandStore } from "./application-command-store.js";
import { MessageComponentStore } from "./message-component-store.js";
import type { BaseCommandOption, CommandOption, CommandStructure, SubCommandStructure } from "./application-command-store.js";
import type { ComponentStructure, DynamicComponentStructure } from "./message-component-store.js";
import type { HandlerListener } from "./shared.js";
import type { ClientListeners, Transformers, Interaction, Awaitable, Client } from "lilybird";
export declare class Handler<T extends Transformers = Transformers, U extends boolean = false> {
    #private;
    constructor(options: {
        cachePath?: string;
        enableDynamicComponents?: boolean;
        transformers?: Transformers;
        handlerListener?: HandlerListener;
    });
    scanDir(path: string): Promise<void>;
    buttonCollector(component: DynamicComponentStructure): void;
    storeCommand<const O extends Array<CommandOption>>(data: CommandStructure<O, U> & {
        components?: Array<ComponentStructure>;
    }): void;
    subCommandMock<const O extends Array<BaseCommandOption>>(data: SubCommandStructure<O, U>): SubCommandStructure<O, U>;
    storeListener<TR extends Transformers = T, K extends keyof TR = keyof TR>(data: {
        event: K;
        handle: Required<ClientListeners<TR>>[K];
    }): void;
    clearStores(): void;
    getCompilationStack(): {
        functionNames: Array<string>;
        handlers: Array<(...args: any) => any>;
        stack: string;
    } | null;
    compileCommands(): ((client: Client, interaction: Interaction.Structure) => Awaitable<unknown>) | null;
    getListenersObject<TR extends Transformers = Transformers>(includeCommands?: boolean): ClientListeners<TR>;
    loadGlobalCommands(client: Client): Promise<void>;
    getStoredData(): {
        commands: {
            global: ReturnType<ApplicationCommandStore<U>["getStoredGlobalCommands"]>;
            guild: ReturnType<ApplicationCommandStore<U>["getStoredGuildCommands"]>;
        };
        components: ReturnType<MessageComponentStore["getStoredComponents"]>;
        listeners: Array<[name: string, handle: (...args: Array<any>) => any]>;
    };
    addDebugListener(listener: HandlerListener): void;
    set cachePath(path: string);
    get cachePath(): string | undefined;
    set enableDynamicComponents(bool: boolean);
    get enableDynamicComponents(): boolean;
}
export declare const handler: Handler<Transformers, false>;
export declare const $applicationCommand: <const O extends Array<CommandOption>>(data: CommandStructure<O, false> & {
    components?: Array<ComponentStructure>;
}) => void;
export declare const $subCommand: <const O extends Array<BaseCommandOption>>(data: SubCommandStructure<O, false>) => SubCommandStructure<O, false>;
export declare const $listener: <TR extends Transformers = Transformers, K extends keyof TR = keyof TR>(data: {
    event: K;
    handle: Required<ClientListeners<TR>>[K];
}) => void;
export declare const $component: (component: DynamicComponentStructure) => void;
//# sourceMappingURL=handler.d.ts.map