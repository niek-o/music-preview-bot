import { ApplicationCommandOptionType } from "lilybird";
import type { Client, ApplicationCommand, Awaitable, Interaction } from "lilybird";
import type { HandlerListener } from "./shared.js";
import type { Interaction as TransformedInteraction, ApplicationCommandData, AutocompleteData } from "@lilybird/transformers";
type Expand<T> = T extends T ? {
    [K in keyof T]: T[K];
} : never;
type U2I<U> = (U extends U ? (u: U) => 0 : never) extends (i: infer I) => 0 ? Extract<I, U> : never;
type ParseOption<O extends BaseCommandOption> = O["required"] extends true ? {
    -readonly [K in keyof O as K extends "name" ? O[K] : never]: MapOptionType<O["type"]>;
} : {
    -readonly [K in keyof O as K extends "name" ? O[K] : never]: MapOptionType<O["type"]> | undefined;
};
type ParseOptions<O extends Array<CommandOption>> = U2I<{
    [K in keyof O]: O[K] extends BaseCommandOption ? ParseOption<O[K]> : never;
}[number]>;
type MapOptionType<T extends ApplicationCommandOptionType> = T extends ApplicationCommandOptionType.INTEGER | ApplicationCommandOptionType.NUMBER ? number : T extends ApplicationCommandOptionType.BOOLEAN ? boolean : string;
export type ApplicationCommandHandler<O extends Array<CommandOption>, U extends boolean> = U extends true ? (interaction: TransformedInteraction<ApplicationCommandData>) => Awaitable<unknown> : (client: Client, interaction: Interaction.ApplicationCommandInteractionStructure, options: Expand<ParseOptions<O>>) => Awaitable<unknown>;
export type ApplicationAutocompleteHandler<O extends Array<CommandOption>, U extends boolean> = U extends true ? (interaction: TransformedInteraction<AutocompleteData>) => Awaitable<unknown> : (client: Client, interaction: Interaction.ApplicationCommandInteractionStructure, options: Expand<ParseOptions<O>>) => Awaitable<unknown>;
interface CompiledCommand {
    body: {
        command: string;
        autocomplete: string | null;
    };
    function: {
        names: Array<string>;
        handlers: Array<ApplicationCommandHandler<Array<CommandOption>, boolean> | ApplicationAutocompleteHandler<Array<CommandOption>, boolean>>;
    };
    json: ApplicationCommand.Create.ApplicationCommandJSONParams & {
        __meta?: {
            ids?: string;
        };
    };
}
export interface CommandStructure<O extends Array<CommandOption>, U extends boolean> extends Omit<ApplicationCommand.Create.ApplicationCommandJSONParams, "options"> {
    options?: O;
    meta?: CommandMeta;
    handle?: ApplicationCommandHandler<O, U>;
    autocomplete?: ApplicationAutocompleteHandler<O, U>;
}
export type CommandOption = BaseCommandOption | SubCommandStructure<Array<BaseCommandOption>, boolean> | SubCommandGroupOption;
export type BaseCommandOption = Exclude<ApplicationCommand.Option.Structure, ApplicationCommand.Option.SubCommandStructure>;
export interface SubCommandStructure<O extends Array<BaseCommandOption>, U extends boolean> extends ApplicationCommand.Option.Base {
    type: ApplicationCommandOptionType.SUB_COMMAND;
    options?: O;
    handle: ApplicationCommandHandler<O, U>;
    autocomplete?: ApplicationAutocompleteHandler<O, U>;
}
interface SubCommandGroupOption extends ApplicationCommand.Option.Base {
    type: ApplicationCommandOptionType.SUB_COMMAND_GROUP;
    options: Array<SubCommandStructure<Array<BaseCommandOption>, boolean>>;
}
interface CommandMeta {
    guild_command?: boolean;
    ids?: Array<string>;
}
export declare class ApplicationCommandStore<U extends boolean> {
    #private;
    constructor(handlerListener?: HandlerListener, transformer?: (interaction: Interaction.Structure) => Awaitable<unknown>);
    storeCommand<const O extends Array<CommandOption>>(command: CommandStructure<O, U>): void;
    getCompilationStack(): {
        functionNames: IterableIterator<string>;
        handlers: IterableIterator<(...args: any) => any>;
        stack: string;
    } | null;
    compile(): ((client: Client, interaction: Interaction.Structure) => Awaitable<unknown>) | null;
    getStoredGlobalCommands(): Array<CompiledCommand>;
    getStoredGuildCommands(): Array<CompiledCommand>;
    clear(): void;
}
export declare function innerOptionParser(options: ApplicationCommand.DataStructure["options"], _obj: Record<string, unknown>): void;
export {};
//# sourceMappingURL=application-command-store.d.ts.map