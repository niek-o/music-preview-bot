import { defaultTransformers } from "@lilybird/transformers";
import { join } from "node:path";
export class Handler {
    guildApplicationCommands = new Map();
    globalApplicationCommands = new Map();
    messageCommands = new Map();
    events = new Map();
    messageCommandAliases = new Map();
    dirs;
    prefix;
    #globMatcher = new Bun.Glob("**/*.{ts,tsx,js,jsx}");
    constructor(dirs, prefix) {
        this.dirs = dirs;
        this.prefix = prefix ?? "!";
    }
    async registerGlobalCommands(client) {
        await client.rest.bulkOverwriteGlobalApplicationCommand(client.user.id, [...this.globalApplicationCommands.values()].map((e) => e.data));
    }
    async registerGuildCommands(client) {
        for await (const command of this.guildApplicationCommands.values()) {
            if (Array.isArray(command.post)) {
                const temp = [];
                for (let i = 0; i < command.post.length; i++)
                    temp.push(client.rest.createGuildApplicationCommand(client.user.id, command.post[i], command.data));
                await Promise.all(temp);
            }
            else
                await client.rest.createGuildApplicationCommand(client.user.id, command.post, command.data);
        }
    }
    async readSlashCommandDir(dir = this.dirs.slashCommands) {
        if (typeof dir === "undefined")
            return false;
        const files = this.#globMatcher.scan(dir);
        for await (const fileName of files) {
            if (fileName.endsWith(".d.ts"))
                continue;
            const command = (await import(join(dir, fileName))).default;
            if (typeof command === "undefined")
                continue;
            if (fileName.startsWith("/guild") || command.post !== "GLOBAL")
                this.guildApplicationCommands.set(command.data.name, command);
            else
                this.globalApplicationCommands.set(command.data.name, command);
        }
        return true;
    }
    async readEventDir(dir = this.dirs.listeners) {
        if (typeof dir === "undefined")
            return false;
        const files = this.#globMatcher.scan(dir);
        for await (const fileName of files) {
            if (fileName.endsWith(".d.ts"))
                continue;
            const event = (await import(join(dir, fileName))).default;
            if (typeof event === "undefined")
                continue;
            this.events.set(event.event, event);
        }
        return true;
    }
    async readMessageCommandDir(dir = this.dirs.messageCommands) {
        if (typeof dir === "undefined")
            return false;
        const files = this.#globMatcher.scan(dir);
        for await (const fileName of files) {
            if (fileName.endsWith(".d.ts"))
                continue;
            const command = (await import(join(dir, fileName))).default;
            if (typeof command === "undefined")
                continue;
            if (typeof command.alias !== "undefined" && command.alias.length > 0) {
                if (command.alias.length === 1)
                    this.messageCommandAliases.set(command.alias[0], command.name);
                else
                    for (let i = 0, { length } = command.alias; i < length; i++)
                        this.messageCommandAliases.set(command.alias[i], command.name);
            }
            this.messageCommands.set(command.name, command);
        }
        return true;
    }
    async onInteraction(interaction) {
        if (interaction.isApplicationCommandInteraction()) {
            await this.globalApplicationCommands.get(interaction.data.name)?.run(interaction);
            if (interaction.inGuild())
                await this.guildApplicationCommands.get(interaction.data.name)?.run(interaction);
        }
        else if (interaction.isAutocompleteInteraction()) {
            await this.globalApplicationCommands.get(interaction.data.name)?.autocomplete?.(interaction);
            if (interaction.inGuild())
                await this.guildApplicationCommands.get(interaction.data.name)?.autocomplete?.(interaction);
        }
    }
    async onMessage(message) {
        if (message.author.bot || (await message.fetchChannel()).isDM())
            return;
        if (message.content?.startsWith(this.prefix)) {
            const args = message.content.slice(this.prefix.length).trim().split(/\s+/g);
            if (args.length === 0)
                return;
            const alias = args.shift().toLowerCase();
            let command = this.messageCommands.get(alias);
            let name = alias;
            if (typeof command === "undefined") {
                name = this.messageCommandAliases.get(alias);
                if (typeof name !== "string")
                    return;
                command = this.messageCommands.get(name);
                if (typeof command === "undefined")
                    return;
            }
            if (command.enabled ?? true)
                await command.run(message, args, { name, alias });
        }
    }
    async buildListeners() {
        const slashCommandsExist = await this.readSlashCommandDir();
        const messageCommandsExist = await this.readMessageCommandDir();
        const eventsExist = await this.readEventDir();
        let interactionCreateFn = undefined;
        let messageCreateFn = undefined;
        const listeners = {};
        if (eventsExist) {
            for (const [name, event] of this.events) {
                if (name === "interactionCreate") {
                    interactionCreateFn = event.run;
                    continue;
                }
                if (name === "messageCreate") {
                    messageCreateFn = event.run;
                    continue;
                }
                listeners[name] = event.run;
            }
        }
        if (!slashCommandsExist)
            listeners.interactionCreate = interactionCreateFn;
        else if (typeof interactionCreateFn !== "undefined") {
            listeners.interactionCreate = async (interaction) => {
                await interactionCreateFn(interaction);
                await this.onInteraction(interaction);
            };
        }
        else {
            listeners.interactionCreate = async (interaction) => {
                await this.onInteraction(interaction);
            };
        }
        if (!messageCommandsExist)
            listeners.messageCreate = messageCreateFn;
        else if (typeof messageCreateFn !== "undefined") {
            listeners.messageCreate = async (message) => {
                await messageCreateFn(message);
                await this.onMessage(message);
            };
        }
        else {
            listeners.messageCreate = async (message) => {
                await this.onMessage(message);
            };
        }
        return listeners;
    }
}
export async function createHandler({ dirs, prefix }) {
    const handler = new Handler(dirs, prefix);
    return {
        transformers: defaultTransformers,
        listeners: await handler.buildListeners(),
        customCacheKeys: {
            guild_voice_states: "voiceStates"
        },
        setup: async (client) => {
            await handler.registerGlobalCommands(client);
            await handler.registerGuildCommands(client);
        }
    };
}
