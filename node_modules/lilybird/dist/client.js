import { CachingManager } from "./cache/manager.js";
import { DebugREST, REST } from "./http/rest.js";
import { WebSocketManager } from "#ws";
import { GatewayEvent } from "#enums";
export class Client {
    rest;
    cache;
    #ws;
    #debug;
    ready = false;
    constructor(options, debug) {
        this.rest = options.useDebugRest === true ? new DebugREST(debug) : new REST();
        this.cache = typeof options.caching?.manager !== "undefined" ? options.caching.manager : new CachingManager();
        this.#debug = debug ?? (() => { });
        this.#ws = new WebSocketManager({
            intents: options.intents,
            presence: options.presence
        }, this.#generateListeners(options), debug);
    }
    async login(token) {
        this.#ws.options = { token };
        this.rest.setToken(token);
        await this.#ws.connect();
        return token;
    }
    close() {
        this.rest.setToken(undefined);
        this.#ws.close();
    }
    setPresence(presence) {
        this.#ws.updatePresence(presence);
    }
    async ping() {
        const start = performance.now();
        await this.rest.getGateway();
        const final = performance.now() - start;
        return {
            ws: await this.#ws.ping(),
            rest: final
        };
    }
    __updateResumeInfo(url, id) {
        Object.assign(this.#ws.resumeInfo, {
            url,
            id
        });
    }
    #generateListeners(options) {
        const builder = new Map();
        const functions = new Map();
        const { listeners, caching } = options;
        const transformers = (options.transformers ?? {});
        if (typeof listeners.raw !== "undefined") {
            functions.set("raw", listeners.raw);
            builder.set("RAW", "await raw(data);");
        }
        const readyArr = [];
        readyArr.push("if(data.t === \"READY\"){", "Object.assign(client,{user:");
        if (typeof transformers.userUpdate !== "undefined") {
            if (transformers.userUpdate.return === 1)
                throw new Error("The transformer for 'userUpdate' should only return 1 value");
            functions.set("t_userUpdate", transformers.userUpdate.handler);
            readyArr.push("await t_userUpdate(client, data.d.user)");
        }
        else
            readyArr.push("data.d.user");
        readyArr.push(",sessionId:data.d.session_id,application:data.d.application});", "client.__updateResumeInfo(data.d.resume_gateway_url, data.d.session_id);", "if(!client.ready){client.ready=true;");
        if (typeof options.setup !== "undefined") {
            functions.set("setup", options.setup);
            readyArr.push("await setup(client);");
        }
        readyArr.push("}");
        if (typeof listeners.ready !== "undefined") {
            functions.set("ready", listeners.ready);
            const transformer = transformers.ready;
            if (typeof transformer !== "undefined") {
                functions.set("t_ready", transformer.handler);
                switch (transformer.return) {
                    case 0: {
                        readyArr.push("await ready(t_ready(client, data.d));");
                        break;
                    }
                    case 1: {
                        readyArr.push("await ready(...t_ready(client, data.d));");
                        break;
                    }
                }
            }
            else
                readyArr.push("await ready(client, data.d);");
        }
        readyArr.push("}");
        builder.set("READY", readyArr.join(""));
        for (let i = 0, listenerEntries = Object.entries(listeners), { length } = listenerEntries; i < length; i++) {
            const [handlerName, handler] = listenerEntries[i];
            if (handlerName === "raw" || handlerName === "ready")
                continue;
            if (typeof handler === "undefined")
                continue;
            const name = `${handlerName[0].toUpperCase()}${handlerName.slice(1)}`;
            const event = GatewayEvent[name];
            const transformer = transformers[handlerName];
            this.#createListener(builder, functions, event, name, handler, transformer);
        }
        if (typeof caching !== "undefined" && caching.delegate !== 2) {
            if (caching.delegate === 1 && caching.applyTransformers === true && !caching.safeToTransform) {
                process.emitWarning("Transformers will be applied to external solution!", {
                    code: "EXTERNAL_TRANSFORMERS",
                    detail: "Some external caching managers might not support transformers, please read their documentation before proceeding."
                });
            }
            if (Object.keys(caching.enabled).length === 0)
                throw new Error("Got unexpected empty object");
            const defaults = {
                create: 0,
                update: 1,
                delete: 1
            };
            const enabledGuild = caching.enabled.guild === true ? defaults : typeof caching.enabled.guild === "object" ? caching.enabled.guild : undefined;
            const enabledChannel = caching.enabled.channel === true ? defaults : typeof caching.enabled.channel === "object" ? caching.enabled.channel : undefined;
            const enabledThreads = caching.enabled.channel === true
                ? defaults
                : typeof caching.enabled.channel === "object"
                    ? caching.enabled.channel.threads === true
                        ? defaults
                        : typeof caching.enabled.channel.threads === "object"
                            ? caching.enabled.channel.threads
                            : undefined
                    : undefined;
            if (typeof caching.enabled.voiceState !== "undefined" && typeof enabledGuild?.create === "undefined")
                throw new Error("The 'voiceState' cache needs the `guildCreate' cache to be enabled");
            if (typeof enabledGuild?.create !== "undefined") {
                const temp = [];
                if (typeof enabledChannel?.create !== "undefined") {
                    if (caching.applyTransformers) {
                        if (!functions.has("t_channelCreate")) {
                            if (typeof transformers.channelCreate === "undefined")
                                throw Error("Missing 'channelCreate' transformer");
                            functions.set("t_channelCreate", transformers.channelCreate.handler);
                        }
                    }
                    temp.push("for (let i = 0, {channels} = td, {length} = channels; i < length; i++){", `const channel = ${caching.applyTransformers ? "t_channelCreate(client, channels[i])" : "channels[i]"};`, `await client.cache.set(${1}, channel.id, channel);`, "}");
                }
                if (typeof enabledThreads?.create !== "undefined") {
                    if (caching.applyTransformers) {
                        if (!functions.has("t_channelCreate")) {
                            if (typeof transformers.channelCreate === "undefined")
                                throw Error("Missing 'channelCreate' transformer");
                            functions.set("t_channelCreate", transformers.channelCreate.handler);
                        }
                    }
                    temp.push("for (let i = 0, {threads} = td, {length} = threads; i < length; i++){", `const channel = ${caching.applyTransformers ? "t_channelCreate(client, threads[i])" : "threads[i]"};`, `await client.cache.set(${1}, channel.id, channel);`, "}");
                }
                if (typeof caching.enabled.voiceState !== "undefined") {
                    if (caching.applyTransformers) {
                        if (!functions.has("t_voiceStateUpdate")) {
                            if (typeof transformers.voiceStateUpdate === "undefined")
                                throw Error("Missing 'voiceStateUpdate' transformer");
                            functions.set("t_voiceStateUpdate", transformers.voiceStateUpdate.handler);
                        }
                    }
                    const key = caching.customKeys?.guild_voice_states ?? "voice_states";
                    const vCid = caching.customKeys?.voice_state_channel_id ?? "channel_id";
                    const vUid = caching.customKeys?.voice_state_user_id ?? "user_id";
                    this.#createListener(builder, functions, GatewayEvent.VoiceStateUpdate, "voiceStateUpdate", listeners.voiceStateUpdate, transformers.voiceStateUpdate, {
                        when: caching.enabled.voiceState,
                        content: `await client.cache.set(${2}, ${caching.applyTransformers
                            ? `\`\${td.${vUid}}:\${td.${vCid}}\``
                            : `\`\${data.d.${vUid}}:\${data.d.${vCid}}\``}, data.d);`
                    });
                    temp.push(`for (let i = 0, {${key}} = td, {length} = ${key}; i < length; i++){`, `const voice = ${caching.applyTransformers ? `t_voiceStateUpdate(client, ${key}[i])` : `${key}[i]`};`, `await client.cache.set(${2}, \`\${voice.${vUid}}:\${voice.${vCid}}\`, voice);`, "}");
                }
                temp.push(`await client.cache.set(${0},`, caching.applyTransformers ? "td.id, td" : "data.d.id, {...data.d,channels: undefined,threads:undefined,voice_states:undefined}", ");");
                this.#createListener(builder, functions, GatewayEvent.GuildCreate, "guildCreate", listeners.guildCreate, transformers.guildCreate, { when: enabledGuild.create, content: temp.join("") });
            }
            if (typeof enabledGuild?.update !== "undefined") {
                this.#createListener(builder, functions, GatewayEvent.GuildUpdate, "guildUpdate", listeners.guildUpdate, transformers.guildUpdate, {
                    when: enabledGuild.update,
                    content: `await client.cache.set(${0}, ${caching.applyTransformers ? "td.id, td" : "data.d.id, data.d"});`
                });
            }
            if (typeof enabledGuild?.delete !== "undefined") {
                this.#createListener(builder, functions, GatewayEvent.GuildDelete, "guildDelete", listeners.guildDelete, transformers.guildDelete, {
                    when: enabledGuild.delete,
                    content: `await client.cache.delete(${0}, ${caching.applyTransformers ? "td.id" : "data.d.id"});`
                });
            }
            if (typeof enabledChannel?.create !== "undefined") {
                this.#createListener(builder, functions, GatewayEvent.ChannelCreate, "channelCreate", listeners.channelCreate, transformers.channelCreate, {
                    when: enabledChannel.create,
                    content: `await client.cache.set(${1}, ${caching.applyTransformers ? "td.id, td" : "data.d.id, data.d"});`
                });
            }
            if (typeof enabledChannel?.update !== "undefined") {
                this.#createListener(builder, functions, GatewayEvent.ChannelUpdate, "channelUpdate", listeners.channelUpdate, transformers.channelUpdate, {
                    when: enabledChannel.update,
                    content: `await client.cache.set(${1}, ${caching.applyTransformers ? "td.id, td" : "data.d.id, data.d"});`
                });
            }
            if (typeof enabledChannel?.delete !== "undefined") {
                this.#createListener(builder, functions, GatewayEvent.ChannelDelete, "channelDelete", listeners.channelDelete, transformers.channelDelete, {
                    when: enabledChannel.delete,
                    content: `await client.cache.delete(${1}, ${caching.applyTransformers ? "td.id" : "data.d.id"});`
                });
            }
            if (typeof enabledThreads?.create !== "undefined") {
                this.#createListener(builder, functions, GatewayEvent.ThreadCreate, "threadCreate", listeners.threadCreate, transformers.threadCreate, {
                    when: enabledThreads.create,
                    content: `await client.cache.set(${1}, ${caching.applyTransformers ? "td.id, td" : "data.d.id, data.d"});`
                });
            }
            if (typeof enabledThreads?.update !== "undefined") {
                this.#createListener(builder, functions, GatewayEvent.ThreadUpdate, "threadUpdate", listeners.threadUpdate, transformers.threadUpdate, {
                    when: enabledThreads.update,
                    content: `await client.cache.set(${1}, ${caching.applyTransformers ? "td.id, td" : "data.d.id, data.d"});`
                });
            }
            if (typeof enabledThreads?.delete !== "undefined") {
                this.#createListener(builder, functions, GatewayEvent.ThreadDelete, "threadDelete", listeners.threadDelete, transformers.threadDelete, {
                    when: enabledThreads.delete,
                    content: `await client.cache.delete(${1}, ${caching.applyTransformers ? "td.id" : "data.d.id"});`
                });
            }
            if (typeof caching.enabled.self !== "undefined") {
                if (caching.applyTransformers) {
                    if (!functions.has("t_userUpdate")) {
                        if (typeof transformers.userUpdate === "undefined")
                            throw new Error("Missing 'userUpdate' transformer");
                        if (transformers.userUpdate.return === 1)
                            throw new Error("The transformer for 'userUpdate' should only return 1 value");
                        functions.set("t_userUpdate", transformers.userUpdate.handler);
                    }
                }
                this.#createListener(builder, functions, GatewayEvent.UserUpdate, "userUpdate", listeners.userUpdate, transformers.userUpdate, {
                    when: caching.enabled.self,
                    content: `client.user = ${caching.applyTransformers ? "td" : "data.d"}`
                });
            }
        }
        const names = functions.keys();
        const handlers = functions.values();
        const compiledListeners = [...builder.values()].join("");
        this.#debug(13, compiledListeners);
        return new Function("client", ...names, `return async (data) => { ${compiledListeners} }`)(this, ...handlers);
    }
    #createListener(builder, functions, event, name, handler, transformer, extra = undefined) {
        const temp = [`else if(data.t === "${event}"){`];
        if (typeof handler !== "undefined")
            functions.set(name, handler);
        const transf = `t_${name}`;
        if (typeof transformer !== "undefined") {
            functions.set(transf, transformer.handler);
            switch (transformer.return) {
                case 0: {
                    if (typeof extra !== "undefined") {
                        if (extra.when === 0) {
                            temp.push(`const td = await ${transf}(client, data.d);`, extra.content, typeof handler !== "undefined" ? `await ${name}(td)` : "");
                        }
                        else {
                            temp.push(`const td = await ${transf}(client, data.d);`, typeof handler !== "undefined" ? `await ${name}(td)` : "", extra.content);
                        }
                    }
                    else if (typeof handler !== "undefined")
                        temp.push(`await ${name}(await ${transf}(client, data.d));`);
                    break;
                }
                case 1: {
                    if (typeof extra !== "undefined") {
                        if (extra.when === 0) {
                            temp.push(`const td = await ${transf}(client, data.d);`, extra.content, typeof handler !== "undefined" ? `await ${name}(...td);` : "");
                        }
                        else {
                            temp.push(`const td = await ${transf}(client, data.d);`, typeof handler !== "undefined" ? `await ${name}(...td);` : "", extra.content);
                        }
                    }
                    else if (typeof handler !== "undefined")
                        temp.push(`await ${name}(...(await ${transf}(client, data.d)));`);
                    break;
                }
            }
        }
        else if (typeof extra !== "undefined") {
            if (extra.when === 0)
                temp.push("const td = data.d;", extra.content, typeof handler !== "undefined" ? `await ${name}(client, td);` : "");
            else
                temp.push("const td = data.d;", typeof handler !== "undefined" ? `await ${name}(client, td);` : "", extra.content);
        }
        else if (typeof handler !== "undefined")
            temp.push(`await ${name}(client, data.d);`);
        if (temp.length === 1)
            return;
        if (temp.length === 4) {
            if (temp[2] === "") {
                temp[2] = temp[3];
                temp.pop();
            }
            else if (temp[3] === "")
                temp.pop();
            if (!temp[1].startsWith("const td ="))
                throw new Error("There was something wrong internally with the compiler");
            if (temp.length === 4 && !temp[3].includes("td")) {
                if (!temp[2].includes("td")) {
                    temp[1] = temp[2];
                    temp[2] = temp.pop();
                    functions.delete(transf);
                }
            }
            else if (temp.length === 3 && !temp[2].includes("td")) {
                temp[1] = temp.pop();
                functions.delete(transf);
            }
        }
        temp.push("}");
        builder.set(event, temp.join(""));
    }
}
export async function createClient(options) {
    if (typeof options.caching?.customKeys !== "undefined")
        options.caching.customKeys = { ...options.customCacheKeys, ...options.caching.customKeys };
    else if (typeof options.caching !== "undefined")
        options.caching.customKeys = options.customCacheKeys;
    return new Promise((res) => {
        new Client({
            intents: Array.isArray(options.intents) ? options.intents.reduce((prev, curr) => prev | curr, 0) : options.intents,
            listeners: options.listeners,
            transformers: options.transformers,
            presence: options.presence,
            caching: options.caching,
            useDebugRest: options.useDebugRest ?? options.attachDebugListener,
            setup: typeof options.setup !== "undefined" ? async (client) => { await options.setup(client); res(client); } : res
        }, options.attachDebugListener
            ? options.debugListener ?? ((identifier, payload) => {
                console.log(identifier, payload ?? "");
            })
            : undefined).login(options.token);
    });
}
